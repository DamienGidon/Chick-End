using System;
using System.Collections.Generic;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace ITI.S3.PI.Chick_End
{
    public abstract class Tower : Unit, IAssailant
    {
        protected readonly Square _square;
        internal readonly int _damages;
        protected readonly Square[] _range;

<<<<<<< Updated upstream
        protected Tower(Square context, int damages)
        {
            _square = context;
            _range = GetRange();
            _damages = damages;
            
=======
        protected Tower( Square context, int damages )
        {
            _square = context;
            _range = ComputeRange().ToArray();
            _damages = damages;
>>>>>>> Stashed changes
        }

        public int Damages
        {
            get { return _damages; }
        }

        public override Square Square
        {
            get { return _square; }
        }

        public override Point Position
        {
<<<<<<< Updated upstream
            Ennemi closestEnnemi = null;
            List<Ennemi> test = new List<Ennemi>();

            int thisX = _square.Column * FinalVariables._squareWidthInMeters + FinalVariables._squareWidthInMeters / 2;
            int thisY = _square.Line * FinalVariables._squareHeightInMeters + FinalVariables._squareHeightInMeters / 2;


            test = _square.Context.Ennemis.Where(e => _range.Contains(e.Position)).ToList();
            double minpyth = -1;
            foreach (var en in test)
            {
                double a = pyth(Math.Max(thisX, en.X)-Math.Min(thisX, en.X), Math.Max(thisY, en.Y) - Math.Min(thisY, en.Y));
                if (minpyth == -1)
                {
                    minpyth = a;
                    closestEnnemi = en;
                }
                if (a < minpyth)
                {
                    minpyth = a;
                    closestEnnemi = en;
                }
            }
            

            return closestEnnemi;
=======
            get { return new Point( _square.Column * FinalVariables._squareWidthInMeters + FinalVariables._squareWidthInMeters / 2, _square.Line * FinalVariables._squareHeightInMeters + FinalVariables._squareHeightInMeters / 2 ); }
>>>>>>> Stashed changes
        }

        public IReadOnlyList<Square> Range
        {
            get { return _range; }
        }

        public Ennemi GetClosestEnnemiAttackable()
        {
            return this.GetClosestUnit( _square.Context.Ennemis );
            //return UnitExtension.GetClosestUnit( this, _square.Context.Ennemis );
            //return GetClosestUnit<Ennemi>( _square.Context.Ennemis );
        }

        public virtual List<Square> ComputeRange()
        {
            List<Square> squaresInRange = new List<Square>();
            int line = _square.Line;
            int column = _square.Column;
            
            for( int i = column; i < FinalVariables._nbCaseWidth; i++ )
            {
                if (_square.Context.Square[line, i].Decoration == "path")
                    squaresInRange.Add( _square.Context.Square[line, i] );
                else
                    break;
            }
            
            for( int i = line + 1; i<FinalVariables._nbCaseHeight; i++ )
            {
                if( _square.Context.Square[i, column].Decoration == "path" )
                    squaresInRange.Add( _square.Context.Square[i, column] );
                else
                    break;
            }

            for (int i = line - 1; i >= 0; i--)
            {
                if (_square.Context.Square[i, column].Decoration == "path")
                    squaresInRange.Add( _square.Context.Square[i, column] );
                else
                    break;
            }

            return squaresInRange;
        }
<<<<<<< Updated upstream
        public double pyth(int diffX, int diffY)
        {
            return (Math.Sqrt(diffX * diffX + diffY * diffY));
        }
}
=======

        public virtual void Attack( Unit ennemi )
        {
            throw new NotImplementedException();
        }
    }
>>>>>>> Stashed changes
}
